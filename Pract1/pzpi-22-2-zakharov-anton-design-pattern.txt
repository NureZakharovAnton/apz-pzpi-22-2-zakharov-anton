Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії



ЗВІТ
до практичної роботи номер 2 з дисципліни 
"Архітектура програмного забезпечення"
на тему: " Патерни проєктування"







Виконав ст. гр. ПЗПІ-22-2
Захаров Антон Володимирович

Перевірив
ст. викладач кафедри ПІ
Володимир Олександрович Лещинський
 



Харків 2025
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	14.03.2025	0.1	Створено розділи «Завдання», «Опис виконаної роботи» та «Висновки»
2	15.03.2025	0.2	Створено додатки «Додаток А», «Додаток Б», «Додаток В»


2 ЗАВДАННЯ

Ознайомитися з шаблоном проєктування Decorator, вивчити його призначення та практичне застосування. Розглянути приклади реалізації на мові TypeScript, продемонструвавши декоратори для класів, методів, властивостей і параметрів.

3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Теоретична частина
Шаблон Decorator (Декоратор) належить до групи структурних шаблонів і дозволяє динамічно змінювати або доповнювати поведінку об’єктів. Головною ідеєю є обгортання об'єкта в інший об'єкт-декоратор, що має додаткову функціональність.
Основні переваги використання шаблону:
Динамічне розширення функціоналу без зміни коду існуючих класів.
Дотримання принципу відкритості/закритості (Open/Closed Principle): класи відкриті для розширення, але закриті для модифікації.
Зменшення кількості підкласів завдяки можливості комбінувати поведінку через декоратори.
У TypeScript декоратори є спеціальними функціями, які можуть бути застосовані до різних елементів коду: класів, методів, властивостей та параметрів. Вони дозволяють змінити або доповнити поведінку без втручання у вихідну реалізацію.

3.2 Приклади реалізації шаблону Decorator на TypeScript
Кожен приклад реалізовано окремо (див. додаток В).
3.2.1 Декоратор класу
У цьому прикладі реалізовано декоратор @AddTimestamp, який додає до кожного створеного екземпляра класу властивість createdAt з поточним часом. Наприклад, клас Document отримує цю властивість без потреби змінювати свій конструктор.
Це зручно для автоматичного додавання метаінформації до об'єктів (наприклад, дата створення), логування, або реєстрації змін.

function AddTimestamp(constructor: Function) {
  constructor.prototype.createdAt = new Date();
}

@AddTimestamp
class Document {
  title: string;
  constructor(title: string) {
    this.title = title;
  }
}

3.2.2 Декоратор методу
Метод можна декорувати для додавання додаткової поведінки — наприклад, логування параметрів. У наступному прикладі декоратор @LogParams виводить у консоль аргументи, з якими викликано метод.

function LogParams(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  descriptor.value = function (...args: any[]) {
    console.log(`Виклик методу ${propertyKey} з аргументами:`, args);
    return original.apply(this, args);
  };
  return descriptor;
}

class Calculator {
  @LogParams
  multiply(a: number, b: number): number {
    return a * b;
  }
}
Такий підхід дозволяє вести аудит або налагодження, не змінюючи логіку методу.

3.2.3 Декоратор властивості
Декоратори властивостей можуть використовуватись для прикріплення додаткових метаданих до полів класу. Наприклад, можна створити декоратор @Readonly, який робить властивість незмінною після ініціалізації.


function Readonly(target: any, propertyKey: string) {
  Object.defineProperty(target, propertyKey, {
    writable: false,
    configurable: false
  });
}

class Settings {
  @Readonly
  version: string = "1.0.0";
}
Такий механізм можна застосовувати для захисту конфігураційних або системних значень від небажаного змінення.

3.2.4 Декоратор із параметрами (перевірка діапазону)
Реалізовано декоратор @Range(min, max), який перевіряє, чи потрапляє числове значення у вказаний діапазон.


function Range(min: number, max: number) {
  return function (target: any, propertyKey: string) {
    let value: number;

    const getter = () => value;
    const setter = (newVal: number) => {
      if (newVal < min || newVal > max) {
        throw new Error(`${propertyKey} має бути в діапазоні ${min}-${max}`);
      }
      value = newVal;
    };

    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true
    });
  };
}

class Player {
  @Range(1, 100)
  level: number = 1;
}
Цей тип декораторів особливо зручний для реалізації валідацій бізнес-логіки без дублювання коду.

3.2.5 Декоратор вимірювання часу виконання методу
Для оцінки ефективності методів корисно використовувати декоратор @MeasureTime, який фіксує час виконання.

function MeasureTime(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  descriptor.value = function (...args: any[]) {
    const start = performance.now();
    const result = original.apply(this, args);
    const end = performance.now();
    console.log(`Метод ${propertyKey} виконався за ${end - start} мс`);
    return result;
  };
  return descriptor;
}

class TaskRunner {
  @MeasureTime
  runHeavyTask() {
    for (let i = 0; i < 1e6; i++) {} // імітація важкої задачі
  }
}
Такий підхід використовується для профілювання та оптимізації продуктивності застосунку.

4 ВИСНОВКИ

У процесі виконання завдання було проаналізовано патерн Decorator як засіб динамічного розширення функціональності програмних компонентів без зміни їхньої внутрішньої реалізації. Даний шаблон дозволяє писати гнучкий, масштабований і розширюваний код, що особливо важливо для великих проєктів.
Були розглянуті різні види декораторів у контексті мови TypeScript:
Декоратори класів дозволяють модифікувати або розширювати логіку створення об'єктів, додаючи метаінформацію або поведінку.
Декоратори методів корисні для логування, кешування, валідації та інших задач, які не повинні змінювати основну бізнес-логіку.
Декоратори властивостей застосовуються для захисту даних, додавання валідацій або обробки метаданих.
Декоратори з параметрами дають змогу створювати універсальні, налаштовувані рішення — як-от перевірки діапазону чи довжини.
Декоратори для вимірювання часу виконання дозволяють виявляти слабкі місця в продуктивності, що є корисним для оптимізації системи.
В цілому, патерн Decorator у TypeScript — це потужний інструмент для побудови чистої, масштабованої архітектури. Його активне використання в таких фреймворках як Angular чи NestJS свідчить про його важливість у сучасному розробницькому середовищі.
 
ДОДАТОК Б
 (слайди презентації доповіді)
